"""
Parser for TestExample
Auto-generated by CodeAutoModifier
"""

from typing import Dict, Any, Optional
from bs4 import BeautifulSoup, Tag
import re
import logging

logger = logging.getLogger(__name__)

class TestExampleParser:
    """Parser específico para extraer datos estructurados."""

    def __init__(self):
        self.selectors = 'test-example.com'
        self.fallback_selectors = {
            # Selectores de respaldo automáticos
        }

    def parse(self, soup: BeautifulSoup) -> Dict[str, Any]:
        """Parse HTML y extrae datos estructurados."""
        data = {}

        for field, selector in self.selectors.items():
            try:
                value = self._extract_field(soup, field, selector)
                if value:
                    data[field] = value
            except Exception as e:
                logger.warning(f"Error extracting {field}: {e}")
                # Intentar selector de respaldo
                if field in self.fallback_selectors:
                    try:
                        value = self._extract_field(soup, field, self.fallback_selectors[field])
                        if value:
                            data[field] = value
                    except:
                        pass

        # Post-processing
        data = self._post_process_data(data)

        return data

    def _extract_field(self, soup: BeautifulSoup, field: str, selector: str) -> Optional[str]:
        """Extrae un campo específico usando el selector."""
        element = soup.select_one(selector)

        if not element:
            return None

        # Estrategias de extracción específicas por tipo de campo
        if field in ['price', 'cost', 'amount']:
            return self._extract_price(element)
        elif field in ['title', 'name', 'heading']:
            return self._extract_text(element)
        elif field in ['description', 'content', 'text']:
            return self._extract_rich_text(element)
        elif field in ['url', 'link', 'href']:
            return self._extract_url(element)
        elif field in ['image', 'img', 'photo']:
            return self._extract_image_url(element)
        else:
            return self._extract_text(element)

    def _extract_text(self, element: Tag) -> str:
        """Extrae texto limpio de un elemento."""
        if not element:
            return ""

        text = element.get_text(strip=True)
        # Limpiar texto
        text = re.sub(r'\s+', ' ', text)
        text = text.strip()

        return text

    def _extract_rich_text(self, element: Tag) -> str:
        """Extrae texto preservando algunos elementos de formato."""
        if not element:
            return ""

        # Preservar saltos de línea
        for br in element.find_all("br"):
            br.replace_with("\n")

        text = element.get_text()
        # Normalizar espacios pero preservar saltos de línea
        lines = [line.strip() for line in text.split('\n')]
        return '\n'.join(line for line in lines if line)

    def _extract_price(self, element: Tag) -> Optional[float]:
        """Extrae precio como número."""
        text = self._extract_text(element)

        # Buscar patrones de precio
        price_pattern = r'[\d,]+\.?\d*'
        matches = re.findall(price_pattern, text)

        if matches:
            try:
                # Tomar el primer número encontrado
                price_str = matches[0].replace(',', '')
                return float(price_str)
            except ValueError:
                pass

        return None

    def _extract_url(self, element: Tag) -> Optional[str]:
        """Extrae URL de un elemento."""
        if not element:
            return None

        # Buscar en diferentes atributos
        for attr in ['href', 'src', 'data-url', 'data-href']:
            url = element.get(attr)
            if url:
                return url.strip()

        return None

    def _extract_image_url(self, element: Tag) -> Optional[str]:
        """Extrae URL de imagen."""
        if not element:
            return None

        # Buscar en diferentes atributos de imagen
        for attr in ['src', 'data-src', 'data-original', 'data-lazy']:
            url = element.get(attr)
            if url:
                return url.strip()

        return None

    def _post_process_data(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Post-procesa los datos extraídos."""
        processed = {}

        for key, value in data.items():
            if value is None:
                continue

            if isinstance(value, str):
                # Limpiar strings
                value = value.strip()
                if not value:
                    continue

            processed[key] = value

        return processed

    def validate_data(self, data: Dict[str, Any]) -> bool:
        """Valida que los datos extraídos sean correctos."""
        required_fields = ['title']  # Campos mínimos requeridos

        for field in required_fields:
            if field not in data or not data[field]:
                return False

        return True
